# coding: utf-8

"""
    formulari

    Servizio Formulari RENTRI

    The version of the OpenAPI document: 1.0.20260119-862
    Contact: techref@rentri.it
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator

from typing import List, Optional

from rentri_formulari.models.azioni_result import AzioniResult
from rentri_formulari.models.dati_accettazione_model import DatiAccettazioneModel
from rentri_formulari.models.dati_allegato_model import DatiAllegatoModel
from rentri_formulari.models.dati_annotazione_model import DatiAnnotazioneModel
from rentri_formulari.models.dati_annullamento_model import DatiAnnullamentoModel
from rentri_formulari.models.dati_per_firma_model import DatiPerFirmaModel
from rentri_formulari.models.dati_sosta_tecnica_model import DatiSostaTecnicaModel
from rentri_formulari.models.dati_trasbordo_parziale_model import DatiTrasbordoParzialeModel
from rentri_formulari.models.dati_trasbordo_totale_model import DatiTrasbordoTotaleModel
from rentri_formulari.models.dettaglio_formulario import DettaglioFormulario
from rentri_formulari.models.downloadable_base_response import DownloadableBaseResponse
from rentri_formulari.models.firma_model import FirmaModel
from rentri_formulari.models.formulario_item_result import FormularioItemResult
from rentri_formulari.models.info_formulario import InfoFormulario
from rentri_formulari.models.note_annullamento_model import NoteAnnullamentoModel
from rentri_formulari.models.numero_fir_destinatario_post_request import NumeroFirDestinatarioPostRequest
from rentri_formulari.models.numero_fir_trasporto_post_request import NumeroFirTrasportoPostRequest
from rentri_formulari.models.nuovo_formulario_model import NuovoFormularioModel
from rentri_formulari.models.quantita_rifiuto_model import QuantitaRifiutoModel
from rentri_formulari.models.transazione_model import TransazioneModel
from rentri_formulari.models.upload_xfir_model import UploadXfirModel
from rentri_formulari.models.valida_xfir_model import ValidaXfirModel

from rentri_formulari.api_client import ApiClient
from rentri_formulari.api_response import ApiResponse
from rentri_formulari.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class FormularioDigitaleApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def count_get(self, num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".")] = None, identificativo_soggetto : Annotated[Optional[StrictStr], Field(description="Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".")] = None, solo_senza_visibilita_siti : Annotated[Optional[StrictBool], Field(description="Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.")] = None, numero_fir : Annotated[Optional[StrictStr], Field(description="Numero del FIR")] = None, codice_blocco : Annotated[Optional[StrictStr], Field(description="Codice blocco del FIR")] = None, data_creazione_da : Annotated[Optional[datetime], Field(description="Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_creazione_a : Annotated[Optional[datetime], Field(description="Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_da : Annotated[Optional[datetime], Field(description="Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_a : Annotated[Optional[datetime], Field(description="Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, codice_eer : Annotated[Optional[constr(strict=True, max_length=8)], Field(description="Codice EER")] = None, stati : Optional[conlist(StrictStr)] = None, **kwargs) -> int:  # noqa: E501
        """Conteggio formulari  # noqa: E501

        Ottiene il conteggio dei formulari digitali con visibilit√† per l'unit√† locale indicata e con i filtri specificati.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.count_get(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, async_req=True)
        >>> result = thread.get()

        :param num_iscr_sito: Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".
        :type num_iscr_sito: str
        :param identificativo_soggetto: Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".
        :type identificativo_soggetto: str
        :param solo_senza_visibilita_siti: Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.
        :type solo_senza_visibilita_siti: bool
        :param numero_fir: Numero del FIR
        :type numero_fir: str
        :param codice_blocco: Codice blocco del FIR
        :type codice_blocco: str
        :param data_creazione_da: Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_da: datetime
        :param data_creazione_a: Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_a: datetime
        :param data_emissione_da: Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_da: datetime
        :param data_emissione_a: Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_a: datetime
        :param codice_eer: Codice EER
        :type codice_eer: str
        :param stati:
        :type stati: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: int
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the count_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.count_get_with_http_info(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, **kwargs)  # noqa: E501

    @validate_arguments
    def count_get_with_http_info(self, num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".")] = None, identificativo_soggetto : Annotated[Optional[StrictStr], Field(description="Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".")] = None, solo_senza_visibilita_siti : Annotated[Optional[StrictBool], Field(description="Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.")] = None, numero_fir : Annotated[Optional[StrictStr], Field(description="Numero del FIR")] = None, codice_blocco : Annotated[Optional[StrictStr], Field(description="Codice blocco del FIR")] = None, data_creazione_da : Annotated[Optional[datetime], Field(description="Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_creazione_a : Annotated[Optional[datetime], Field(description="Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_da : Annotated[Optional[datetime], Field(description="Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_a : Annotated[Optional[datetime], Field(description="Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, codice_eer : Annotated[Optional[constr(strict=True, max_length=8)], Field(description="Codice EER")] = None, stati : Optional[conlist(StrictStr)] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Conteggio formulari  # noqa: E501

        Ottiene il conteggio dei formulari digitali con visibilit√† per l'unit√† locale indicata e con i filtri specificati.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.count_get_with_http_info(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, async_req=True)
        >>> result = thread.get()

        :param num_iscr_sito: Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".
        :type num_iscr_sito: str
        :param identificativo_soggetto: Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".
        :type identificativo_soggetto: str
        :param solo_senza_visibilita_siti: Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.
        :type solo_senza_visibilita_siti: bool
        :param numero_fir: Numero del FIR
        :type numero_fir: str
        :param codice_blocco: Codice blocco del FIR
        :type codice_blocco: str
        :param data_creazione_da: Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_da: datetime
        :param data_creazione_a: Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_a: datetime
        :param data_emissione_da: Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_da: datetime
        :param data_emissione_a: Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_a: datetime
        :param codice_eer: Codice EER
        :type codice_eer: str
        :param stati:
        :type stati: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(int, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'num_iscr_sito',
            'identificativo_soggetto',
            'solo_senza_visibilita_siti',
            'numero_fir',
            'codice_blocco',
            'data_creazione_da',
            'data_creazione_a',
            'data_emissione_da',
            'data_emissione_a',
            'codice_eer',
            'stati'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('num_iscr_sito') is not None:  # noqa: E501
            _query_params.append(('num_iscr_sito', _params['num_iscr_sito']))

        if _params.get('identificativo_soggetto') is not None:  # noqa: E501
            _query_params.append(('identificativo_soggetto', _params['identificativo_soggetto']))

        if _params.get('solo_senza_visibilita_siti') is not None:  # noqa: E501
            _query_params.append(('solo_senza_visibilita_siti', _params['solo_senza_visibilita_siti']))

        if _params.get('numero_fir') is not None:  # noqa: E501
            _query_params.append(('numero_fir', _params['numero_fir']))

        if _params.get('codice_blocco') is not None:  # noqa: E501
            _query_params.append(('codice_blocco', _params['codice_blocco']))

        if _params.get('data_creazione_da') is not None:  # noqa: E501
            if isinstance(_params['data_creazione_da'], datetime):
                _query_params.append(('data_creazione_da', _params['data_creazione_da'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_creazione_da', _params['data_creazione_da']))

        if _params.get('data_creazione_a') is not None:  # noqa: E501
            if isinstance(_params['data_creazione_a'], datetime):
                _query_params.append(('data_creazione_a', _params['data_creazione_a'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_creazione_a', _params['data_creazione_a']))

        if _params.get('data_emissione_da') is not None:  # noqa: E501
            if isinstance(_params['data_emissione_da'], datetime):
                _query_params.append(('data_emissione_da', _params['data_emissione_da'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_emissione_da', _params['data_emissione_da']))

        if _params.get('data_emissione_a') is not None:  # noqa: E501
            if isinstance(_params['data_emissione_a'], datetime):
                _query_params.append(('data_emissione_a', _params['data_emissione_a'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_emissione_a', _params['data_emissione_a']))

        if _params.get('codice_eer') is not None:  # noqa: E501
            _query_params.append(('codice_eer', _params['codice_eer']))

        if _params.get('stati') is not None:  # noqa: E501
            _query_params.append(('stati', _params['stati']))
            _collection_formats['stati'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "int",
            '400': None,
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_accettazione_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_accettazione_model : Annotated[DatiAccettazioneModel, Field(..., description="Dati di accettazione del rifiuto")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Accettazione FIR  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati di accettazione del rifiuto da parte del destinatario per il FIR specificato.  L'aggiunta dei dati di accettazione √® consentita solo ad un'utenza che abbia visibilit√† per (o coincida con) il soggetto destinatario che √® in attesa del rifiuto.   Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_accettazione_post(numero_fir, dati_accettazione_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_accettazione_model: Dati di accettazione del rifiuto (required)
        :type dati_accettazione_model: DatiAccettazioneModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_accettazione_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_accettazione_post_with_http_info(numero_fir, dati_accettazione_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_accettazione_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_accettazione_model : Annotated[DatiAccettazioneModel, Field(..., description="Dati di accettazione del rifiuto")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Accettazione FIR  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati di accettazione del rifiuto da parte del destinatario per il FIR specificato.  L'aggiunta dei dati di accettazione √® consentita solo ad un'utenza che abbia visibilit√† per (o coincida con) il soggetto destinatario che √® in attesa del rifiuto.   Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_accettazione_post_with_http_info(numero_fir, dati_accettazione_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_accettazione_model: Dati di accettazione del rifiuto (required)
        :type dati_accettazione_model: DatiAccettazioneModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_accettazione_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_accettazione_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_accettazione_model'] is not None:
            _body_params = _params['dati_accettazione_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/accettazione', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_acquisizione_firma_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge la firma")], firma_model : Annotated[FirmaModel, Field(..., description="Dati necessari per aggiungere la firma al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Imposta dati firma  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati per completare la creazione del file di firma digitale XAdES nel file xFIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto, tra quelli indicati nel formulario, coinvolto nell'operazione di aggiunta delle informazioni da firmare.  Il formulario deve essere in uno stato di attesa di firma, conseguente all'aggiunta di nuove informazioni.  Stati del formulario ammessi: <ul><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazioneSuccessiva</li></ul> Il valore della propriet√† <i>firma</i> deve corrispondere alla firma crittografica calcolata con la chiave privata  associata al certificato X509 indicato nella propriet√† <i>certificato</i>.  Il valore della propriet√† <i>token</i> deve coincidere con il valore restituito dalla precedente invocazione all'endpoint <i>POST /{numero_fir}/hash</i>, utilizzata per richiedere il codice hash da firmare.  In ambiente di <b>PRODUZIONE</b> l'operazione asincrona, con l'identificativo della transazione restituito dall'endpoint, avr√† esito positivo solo se  il codice hash firmato √® stato calcolato sulla base di una data dichiarata di firma successiva alle ore 00:00 del giorno 13/02/2026.  L'art. 7 c.3 del D.M. 59/2023 prevede che il FIR sia sottoscritto da parte degli operatori coinvolti nelle diverse fasi del trasporto,  per cui se il certificato di firma √® intestato ad una persona giuridica deve riferirsi al soggetto firmatario. Esclusivamente in ambiente <b>DEMO</b>, se il certificato firmatario non viene riconosciuto come valido secondo la regola qui descritta, il sistema produrr√† un avviso non bloccante. In ambiente di <b>PRODUZIONE</b> il controllo sar√† bloccante.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_firma_post(numero_fir, firma_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge la firma (required)
        :type numero_fir: str
        :param firma_model: Dati necessari per aggiungere la firma al formulario (required)
        :type firma_model: FirmaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_acquisizione_firma_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_acquisizione_firma_post_with_http_info(numero_fir, firma_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_acquisizione_firma_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge la firma")], firma_model : Annotated[FirmaModel, Field(..., description="Dati necessari per aggiungere la firma al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Imposta dati firma  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati per completare la creazione del file di firma digitale XAdES nel file xFIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto, tra quelli indicati nel formulario, coinvolto nell'operazione di aggiunta delle informazioni da firmare.  Il formulario deve essere in uno stato di attesa di firma, conseguente all'aggiunta di nuove informazioni.  Stati del formulario ammessi: <ul><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazioneSuccessiva</li></ul> Il valore della propriet√† <i>firma</i> deve corrispondere alla firma crittografica calcolata con la chiave privata  associata al certificato X509 indicato nella propriet√† <i>certificato</i>.  Il valore della propriet√† <i>token</i> deve coincidere con il valore restituito dalla precedente invocazione all'endpoint <i>POST /{numero_fir}/hash</i>, utilizzata per richiedere il codice hash da firmare.  In ambiente di <b>PRODUZIONE</b> l'operazione asincrona, con l'identificativo della transazione restituito dall'endpoint, avr√† esito positivo solo se  il codice hash firmato √® stato calcolato sulla base di una data dichiarata di firma successiva alle ore 00:00 del giorno 13/02/2026.  L'art. 7 c.3 del D.M. 59/2023 prevede che il FIR sia sottoscritto da parte degli operatori coinvolti nelle diverse fasi del trasporto,  per cui se il certificato di firma √® intestato ad una persona giuridica deve riferirsi al soggetto firmatario. Esclusivamente in ambiente <b>DEMO</b>, se il certificato firmatario non viene riconosciuto come valido secondo la regola qui descritta, il sistema produrr√† un avviso non bloccante. In ambiente di <b>PRODUZIONE</b> il controllo sar√† bloccante.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_firma_post_with_http_info(numero_fir, firma_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge la firma (required)
        :type numero_fir: str
        :param firma_model: Dati necessari per aggiungere la firma al formulario (required)
        :type firma_model: FirmaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'firma_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_acquisizione_firma_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['firma_model'] is not None:
            _body_params = _params['firma_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/acquisizione-firma', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_acquisizione_num_iscr_sito_post(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> None:  # noqa: E501
        """(Deprecated) ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/acquisizione-visibilita/{numIscrSito} - Acquisizione visibilit√† FIR  # noqa: E501

        Acquisisce la visibilit√† in ricerca sull'unit√† locale specificata di un FIR digitale creato da terzi.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario,  e a cui deve essere riferibile il numero di iscrizione dell'unit√† locale specificata nel parametro <b>num_iscr_sito</b> . L'operazione consente di rendere visibile il FIR digitale in ricerca per una specifica unit√† locale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_num_iscr_sito_post(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_acquisizione_num_iscr_sito_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_acquisizione_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_acquisizione_num_iscr_sito_post_with_http_info(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/acquisizione-visibilita/{numIscrSito} - Acquisizione visibilit√† FIR  # noqa: E501

        Acquisisce la visibilit√† in ricerca sull'unit√† locale specificata di un FIR digitale creato da terzi.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario,  e a cui deve essere riferibile il numero di iscrizione dell'unit√† locale specificata nel parametro <b>num_iscr_sito</b> . L'operazione consente di rendere visibile il FIR digitale in ricerca per una specifica unit√† locale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        warnings.warn("POST /{numero_fir}/acquisizione/{num_iscr_sito} is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'numero_fir',
            'num_iscr_sito'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_acquisizione_num_iscr_sito_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']

        if _params['num_iscr_sito'] is not None:
            _path_params['num_iscr_sito'] = _params['num_iscr_sito']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/{numero_fir}/acquisizione/{num_iscr_sito}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_acquisizione_visibilita_num_iscr_sito_post(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> None:  # noqa: E501
        """Acquisizione visibilit√† FIR  # noqa: E501

        Acquisisce la visibilit√† in ricerca sull'unit√† locale specificata di un FIR digitale creato da terzi.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario,  e a cui deve essere riferibile il numero di iscrizione dell'unit√† locale specificata nel parametro <b>num_iscr_sito</b> . L'operazione consente di rendere visibile il FIR digitale in ricerca per una specifica unit√† locale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_visibilita_num_iscr_sito_post(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_acquisizione_visibilita_num_iscr_sito_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_acquisizione_visibilita_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_acquisizione_visibilita_num_iscr_sito_post_with_http_info(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> ApiResponse:  # noqa: E501
        """Acquisizione visibilit√† FIR  # noqa: E501

        Acquisisce la visibilit√† in ricerca sull'unit√† locale specificata di un FIR digitale creato da terzi.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario,  e a cui deve essere riferibile il numero di iscrizione dell'unit√† locale specificata nel parametro <b>num_iscr_sito</b> . L'operazione consente di rendere visibile il FIR digitale in ricerca per una specifica unit√† locale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_acquisizione_visibilita_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'num_iscr_sito'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_acquisizione_visibilita_num_iscr_sito_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']

        if _params['num_iscr_sito'] is not None:
            _path_params['num_iscr_sito'] = _params['num_iscr_sito']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/{numero_fir}/acquisizione-visibilita/{num_iscr_sito}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_allegato_allegato_id_delete(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], allegato_id : Annotated[StrictInt, Field(..., description="Identificativo dell'allegato all'interno del FIR digitale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Rimuove un allegato  # noqa: E501

        Acquisisce la richiesta di eliminazione di un allegato dal formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto a cui √® stato riferito l'allegato specificato in fase di inserimento.  L'operazione pu√≤ essere eseguita in tutti gli stati, salvo gli stati Annullato e FirmaAnnullamento.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_allegato_id_delete(numero_fir, allegato_id, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param allegato_id: Identificativo dell'allegato all'interno del FIR digitale (required)
        :type allegato_id: int
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_allegato_allegato_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_allegato_allegato_id_delete_with_http_info(numero_fir, allegato_id, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_allegato_allegato_id_delete_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], allegato_id : Annotated[StrictInt, Field(..., description="Identificativo dell'allegato all'interno del FIR digitale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Rimuove un allegato  # noqa: E501

        Acquisisce la richiesta di eliminazione di un allegato dal formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto a cui √® stato riferito l'allegato specificato in fase di inserimento.  L'operazione pu√≤ essere eseguita in tutti gli stati, salvo gli stati Annullato e FirmaAnnullamento.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_allegato_id_delete_with_http_info(numero_fir, allegato_id, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param allegato_id: Identificativo dell'allegato all'interno del FIR digitale (required)
        :type allegato_id: int
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'allegato_id',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_allegato_allegato_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']

        if _params['allegato_id'] is not None:
            _path_params['allegato_id'] = _params['allegato_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/allegato/{allegato_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_allegato_allegato_id_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], allegato_id : Annotated[StrictInt, Field(..., description="Identificativo dell'allegato all'interno del FIR digitale")], **kwargs) -> DownloadableBaseResponse:  # noqa: E501
        """Download un allegato  # noqa: E501

        Restituisce il file allegato al formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto a cui √® stato riferito l'allegato specificato in fase di inserimento.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_allegato_id_get(numero_fir, allegato_id, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param allegato_id: Identificativo dell'allegato all'interno del FIR digitale (required)
        :type allegato_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DownloadableBaseResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_allegato_allegato_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_allegato_allegato_id_get_with_http_info(numero_fir, allegato_id, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_allegato_allegato_id_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], allegato_id : Annotated[StrictInt, Field(..., description="Identificativo dell'allegato all'interno del FIR digitale")], **kwargs) -> ApiResponse:  # noqa: E501
        """Download un allegato  # noqa: E501

        Restituisce il file allegato al formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto a cui √® stato riferito l'allegato specificato in fase di inserimento.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_allegato_id_get_with_http_info(numero_fir, allegato_id, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param allegato_id: Identificativo dell'allegato all'interno del FIR digitale (required)
        :type allegato_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DownloadableBaseResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'allegato_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_allegato_allegato_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']

        if _params['allegato_id'] is not None:
            _path_params['allegato_id'] = _params['allegato_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "DownloadableBaseResponse",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/allegato/{allegato_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_allegato_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_allegato_model : Annotated[DatiAllegatoModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge un allegato  # noqa: E501

        Acquisisce la richiesta di aggiunta di un allegato al formulario digitale specificato.  L'operazione pu√≤ essere eseguita in tutti gli stati, salvo gli stati Annullato e FirmaAnnullamento.  Il file aggiunto all'xFIR viene inserito all'interno del contenitore ZIP e non ncessita di essere firmato.  Il file da allegare non deve superare 1 MB di dimensione, e la dimensione massima del file xFIR risultante non deve superare i 3 MB. I file accettati come allegati da questo endpoint devono necessariamente essere dei file PDF.  Per il recupero dell'allegato √® necessario scaricare il file xFIR.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_post(numero_fir, dati_allegato_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_allegato_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_allegato_model: DatiAllegatoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_allegato_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_allegato_post_with_http_info(numero_fir, dati_allegato_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_allegato_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_allegato_model : Annotated[DatiAllegatoModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge un allegato  # noqa: E501

        Acquisisce la richiesta di aggiunta di un allegato al formulario digitale specificato.  L'operazione pu√≤ essere eseguita in tutti gli stati, salvo gli stati Annullato e FirmaAnnullamento.  Il file aggiunto all'xFIR viene inserito all'interno del contenitore ZIP e non ncessita di essere firmato.  Il file da allegare non deve superare 1 MB di dimensione, e la dimensione massima del file xFIR risultante non deve superare i 3 MB. I file accettati come allegati da questo endpoint devono necessariamente essere dei file PDF.  Per il recupero dell'allegato √® necessario scaricare il file xFIR.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_allegato_post_with_http_info(numero_fir, dati_allegato_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_allegato_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_allegato_model: DatiAllegatoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_allegato_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_allegato_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_allegato_model'] is not None:
            _body_params = _params['dati_allegato_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/allegato', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_annotazione_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_annotazione_model : Annotated[DatiAnnotazioneModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge annotazione  # noqa: E501

        Acquisisce la richiesta di aggiunta di un'annotazione da allegare al formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto del formulario, trasportatore o destinatario, che risulta avere in carico il rifiuto successivamente alle firme di partenza.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li><li>Accettato</li><li>RespintoAccettatoParzialmente</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annotazione_post(numero_fir, dati_annotazione_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_annotazione_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_annotazione_model: DatiAnnotazioneModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_annotazione_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_annotazione_post_with_http_info(numero_fir, dati_annotazione_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_annotazione_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_annotazione_model : Annotated[DatiAnnotazioneModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge annotazione  # noqa: E501

        Acquisisce la richiesta di aggiunta di un'annotazione da allegare al formulario digitale specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto del formulario, trasportatore o destinatario, che risulta avere in carico il rifiuto successivamente alle firme di partenza.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li><li>Accettato</li><li>RespintoAccettatoParzialmente</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annotazione_post_with_http_info(numero_fir, dati_annotazione_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_annotazione_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_annotazione_model: DatiAnnotazioneModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_annotazione_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_annotazione_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_annotazione_model'] is not None:
            _body_params = _params['dati_annotazione_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/annotazione', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_annulla_fir_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Annullamento FIR  # noqa: E501

        Acquisisce la richiesta di annullamento del FIR specificato.  L'operazione pu√≤ essere richiesta solo da un utenza che abbia incarichi per (o coincida con) il soggetto che, tra produttore e trasportatore iniziale, ha vidimato il numero FIR.  L'annullamento pu√≤ essere richiesto solo se il formulario non risulta gi√† essere firmato sia dal produttore che dal trasportatore.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li></ul> Ulteriori condizioni affinch√© l'annullamento sia eseguito sono: <ul><li>Non deve risultare una copia digitale del FIR con lo stesso numero gi√† consegnata dal destinatario</li><li>Non deve risultare (per rifiuti pericolosi) alcuna trasmissione di dati del FIR digitale con lo stesso numero avvenuta da parte di alcun soggetto coinvolto nel FIR.</li></ul> L'operazione di annullamento provvede ad annullare il FIR e la relativa vidimazione.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annulla_fir_post(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_annulla_fir_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_annulla_fir_post_with_http_info(numero_fir, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_annulla_fir_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Annullamento FIR  # noqa: E501

        Acquisisce la richiesta di annullamento del FIR specificato.  L'operazione pu√≤ essere richiesta solo da un utenza che abbia incarichi per (o coincida con) il soggetto che, tra produttore e trasportatore iniziale, ha vidimato il numero FIR.  L'annullamento pu√≤ essere richiesto solo se il formulario non risulta gi√† essere firmato sia dal produttore che dal trasportatore.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li></ul> Ulteriori condizioni affinch√© l'annullamento sia eseguito sono: <ul><li>Non deve risultare una copia digitale del FIR con lo stesso numero gi√† consegnata dal destinatario</li><li>Non deve risultare (per rifiuti pericolosi) alcuna trasmissione di dati del FIR digitale con lo stesso numero avvenuta da parte di alcun soggetto coinvolto nel FIR.</li></ul> L'operazione di annullamento provvede ad annullare il FIR e la relativa vidimazione.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annulla_fir_post_with_http_info(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_annulla_fir_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/annulla-fir', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_annulla_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_annullamento_model : Annotated[DatiAnnullamentoModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """(Deprecated) üîÅ[ASYNC] ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/annulla-fir - Annullamento FIR  # noqa: E501

        Acquisisce la richiesta di annullamento del FIR specificato.  L'annullamento pu√≤ essere richiesto solo se il formulario non risulta gi√† essere firmato sia dal produttore che dal trasportatore.  L'operazione di annullamento provvede ad annullare il FIR e la relativa vidimazione. Questa operazione pu√≤ essere richiesta solo dal soggetto che ha vidimato il numero FIR. Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annulla_post(numero_fir, dati_annullamento_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_annullamento_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_annullamento_model: DatiAnnullamentoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_annulla_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_annulla_post_with_http_info(numero_fir, dati_annullamento_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_annulla_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], dati_annullamento_model : Annotated[DatiAnnullamentoModel, Field(..., description="Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) üîÅ[ASYNC] ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/annulla-fir - Annullamento FIR  # noqa: E501

        Acquisisce la richiesta di annullamento del FIR specificato.  L'annullamento pu√≤ essere richiesto solo se il formulario non risulta gi√† essere firmato sia dal produttore che dal trasportatore.  L'operazione di annullamento provvede ad annullare il FIR e la relativa vidimazione. Questa operazione pu√≤ essere richiesta solo dal soggetto che ha vidimato il numero FIR. Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_annulla_post_with_http_info(numero_fir, dati_annullamento_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param dati_annullamento_model: Insieme delle informazioni riguardanti l'allegato da aggiungere al formulario (required)
        :type dati_annullamento_model: DatiAnnullamentoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn("POST /{numero_fir}/annulla is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_annullamento_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_annulla_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_annullamento_model'] is not None:
            _body_params = _params['dati_annullamento_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/annulla', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_azioni_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], identificativo_soggetto : Annotated[StrictStr, Field(..., description="Codice fiscale del soggetto per il quale si richiedono le azioni possibili")], num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Se valorizzato con il numero di iscrizione di una unit√† locale del soggetto specificato con il parametro <b>identificativo_soggetto</b>, l'unit√† locale acquisisce automaticamente la visibilit√† per il FIR digitale")] = None, **kwargs) -> AzioniResult:  # noqa: E501
        """Operazioni disponibili  # noqa: E501

        Restituisce l'elenco delle azioni che √® possibile eseguire sul formulario indicato, in funzione dello stato in cui si trova, dal soggetto specificato nel parametro <b>identificativo_soggetto</b>.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto specificato nel parametro <b>identificativo_soggetto</b> ed almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_azioni_get(numero_fir, identificativo_soggetto, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param identificativo_soggetto: Codice fiscale del soggetto per il quale si richiedono le azioni possibili (required)
        :type identificativo_soggetto: str
        :param num_iscr_sito: Se valorizzato con il numero di iscrizione di una unit√† locale del soggetto specificato con il parametro <b>identificativo_soggetto</b>, l'unit√† locale acquisisce automaticamente la visibilit√† per il FIR digitale
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AzioniResult
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_azioni_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_azioni_get_with_http_info(numero_fir, identificativo_soggetto, num_iscr_sito, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_azioni_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], identificativo_soggetto : Annotated[StrictStr, Field(..., description="Codice fiscale del soggetto per il quale si richiedono le azioni possibili")], num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Se valorizzato con il numero di iscrizione di una unit√† locale del soggetto specificato con il parametro <b>identificativo_soggetto</b>, l'unit√† locale acquisisce automaticamente la visibilit√† per il FIR digitale")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Operazioni disponibili  # noqa: E501

        Restituisce l'elenco delle azioni che √® possibile eseguire sul formulario indicato, in funzione dello stato in cui si trova, dal soggetto specificato nel parametro <b>identificativo_soggetto</b>.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto specificato nel parametro <b>identificativo_soggetto</b> ed almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_azioni_get_with_http_info(numero_fir, identificativo_soggetto, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param identificativo_soggetto: Codice fiscale del soggetto per il quale si richiedono le azioni possibili (required)
        :type identificativo_soggetto: str
        :param num_iscr_sito: Se valorizzato con il numero di iscrizione di una unit√† locale del soggetto specificato con il parametro <b>identificativo_soggetto</b>, l'unit√† locale acquisisce automaticamente la visibilit√† per il FIR digitale
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AzioniResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'identificativo_soggetto',
            'num_iscr_sito'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_azioni_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        if _params.get('identificativo_soggetto') is not None:  # noqa: E501
            _query_params.append(('identificativo_soggetto', _params['identificativo_soggetto']))

        if _params.get('num_iscr_sito') is not None:  # noqa: E501
            _query_params.append(('num_iscr_sito', _params['num_iscr_sito']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "AzioniResult",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/azioni', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_destinatario_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge il nuovo destinatario")], numero_fir_destinatario_post_request : Annotated[NumeroFirDestinatarioPostRequest, Field(..., description="Informazioni sul nuovo destinatario da aggiungere")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge nuovo destinatario  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati del nuovo destinatario per il rifiuto indicato nel formulario specificato, a seguito del respingimento o della parziale accettazione del rifiuto da parte del destinatario precedente.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto produttore o il soggetto trasportatore che risulta avere  in carico il rifiuto al momento del respingimento.  Stati del formulario ammessi: <ul><li>RespintoAccettatoParzialmente</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_destinatario_post(numero_fir, numero_fir_destinatario_post_request, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge il nuovo destinatario (required)
        :type numero_fir: str
        :param numero_fir_destinatario_post_request: Informazioni sul nuovo destinatario da aggiungere (required)
        :type numero_fir_destinatario_post_request: NumeroFirDestinatarioPostRequest
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_destinatario_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_destinatario_post_with_http_info(numero_fir, numero_fir_destinatario_post_request, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_destinatario_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge il nuovo destinatario")], numero_fir_destinatario_post_request : Annotated[NumeroFirDestinatarioPostRequest, Field(..., description="Informazioni sul nuovo destinatario da aggiungere")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge nuovo destinatario  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati del nuovo destinatario per il rifiuto indicato nel formulario specificato, a seguito del respingimento o della parziale accettazione del rifiuto da parte del destinatario precedente.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto produttore o il soggetto trasportatore che risulta avere  in carico il rifiuto al momento del respingimento.  Stati del formulario ammessi: <ul><li>RespintoAccettatoParzialmente</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_destinatario_post_with_http_info(numero_fir, numero_fir_destinatario_post_request, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge il nuovo destinatario (required)
        :type numero_fir: str
        :param numero_fir_destinatario_post_request: Informazioni sul nuovo destinatario da aggiungere (required)
        :type numero_fir_destinatario_post_request: NumeroFirDestinatarioPostRequest
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'numero_fir_destinatario_post_request',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_destinatario_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['numero_fir_destinatario_post_request'] is not None:
            _body_params = _params['numero_fir_destinatario_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/destinatario', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero del FIR per il quale si richiede il dettaglio")], **kwargs) -> DettaglioFormulario:  # noqa: E501
        """Dettaglio FIR  # noqa: E501

        Restituisce i dati completi del formulario indicato.   L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_get(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero del FIR per il quale si richiede il dettaglio (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DettaglioFormulario
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_get_with_http_info(numero_fir, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero del FIR per il quale si richiede il dettaglio")], **kwargs) -> ApiResponse:  # noqa: E501
        """Dettaglio FIR  # noqa: E501

        Restituisce i dati completi del formulario indicato.   L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_get_with_http_info(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero del FIR per il quale si richiede il dettaglio (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DettaglioFormulario, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "DettaglioFormulario",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_hash_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge la firma")], dati_per_firma_model : Annotated[DatiPerFirmaModel, Field(..., description="Informazioni necessarie per il calcolo del codice hash da firmare")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Calcolo del codice hash da firmare  # noqa: E501

        Acquisisce la richiesta per il calcolo del codice hash di tipo SHA256 da firmare per poter apporre la firma digitale sul formulario.    L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto tra quelli indicati nel formulario   coinvolto nell'operazione di aggiunta delle informazioni da firmare.    Il formulario deve essere in uno stato di attesa di firma, conseguente all'aggiunta di nuove informazioni.    Stati del formulario ammessi:  <ul><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazioneSuccessiva</li></ul>  Questa operazione non muta lo stato del formulario.    Il codice hash SHA256 prodotto da questo endpoint √® calcolato sull'elemento della struttura dati XAdES <i>ds:SignedInfo</i>,  che contiene un riferimento ad una data dichiarata di firma impostata con l'ora corrente al momento dell'invocazione.     Il codice hash dovr√† essere firmato con la chiave privata associata al certificato X509 indicato nella propriet√† <i>certificato</i> del modello di input.    Per completare l'apposizione della firma al formulario digitale dovr√† essere successivamente invocato l'endpoint <i>POST /{numero_fir}/acquisizione-firma</i>   specificando nel modello di input:   <ul><li>lo stesso certificato X509 incluso nell'invocazione di questo endpoint</li><li>lo stesso token ricevuto nell'esito di questa invocazione</li><li>la firma crittografica calcolata con la chiave privata associata al certificato X509</li></ul>  L'art. 7 c.3 del D.M. 59/2023 prevede che il FIR sia sottoscritto da parte degli operatori coinvolti nelle diverse fasi del trasporto,   per cui se il certificato di firma √® intestato ad una persona giuridica deve riferirsi al soggetto firmatario.  Esclusivamente in ambiente <b>DEMO</b>, se il certificato firmatario non viene riconosciuto come valido secondo la regola qui descritta, il sistema produrr√† un avviso non bloccante.  In ambiente di <b>PRODUZIONE</b> il controllo sar√† bloccante.    Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_hash_post(numero_fir, dati_per_firma_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge la firma (required)
        :type numero_fir: str
        :param dati_per_firma_model: Informazioni necessarie per il calcolo del codice hash da firmare (required)
        :type dati_per_firma_model: DatiPerFirmaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_hash_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_hash_post_with_http_info(numero_fir, dati_per_firma_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_hash_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiunge la firma")], dati_per_firma_model : Annotated[DatiPerFirmaModel, Field(..., description="Informazioni necessarie per il calcolo del codice hash da firmare")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Calcolo del codice hash da firmare  # noqa: E501

        Acquisisce la richiesta per il calcolo del codice hash di tipo SHA256 da firmare per poter apporre la firma digitale sul formulario.    L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto tra quelli indicati nel formulario   coinvolto nell'operazione di aggiunta delle informazioni da firmare.    Il formulario deve essere in uno stato di attesa di firma, conseguente all'aggiunta di nuove informazioni.    Stati del formulario ammessi:  <ul><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaProduttore</li><li>FirmaTrasportatoreIniziale</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazioneSuccessiva</li></ul>  Questa operazione non muta lo stato del formulario.    Il codice hash SHA256 prodotto da questo endpoint √® calcolato sull'elemento della struttura dati XAdES <i>ds:SignedInfo</i>,  che contiene un riferimento ad una data dichiarata di firma impostata con l'ora corrente al momento dell'invocazione.     Il codice hash dovr√† essere firmato con la chiave privata associata al certificato X509 indicato nella propriet√† <i>certificato</i> del modello di input.    Per completare l'apposizione della firma al formulario digitale dovr√† essere successivamente invocato l'endpoint <i>POST /{numero_fir}/acquisizione-firma</i>   specificando nel modello di input:   <ul><li>lo stesso certificato X509 incluso nell'invocazione di questo endpoint</li><li>lo stesso token ricevuto nell'esito di questa invocazione</li><li>la firma crittografica calcolata con la chiave privata associata al certificato X509</li></ul>  L'art. 7 c.3 del D.M. 59/2023 prevede che il FIR sia sottoscritto da parte degli operatori coinvolti nelle diverse fasi del trasporto,   per cui se il certificato di firma √® intestato ad una persona giuridica deve riferirsi al soggetto firmatario.  Esclusivamente in ambiente <b>DEMO</b>, se il certificato firmatario non viene riconosciuto come valido secondo la regola qui descritta, il sistema produrr√† un avviso non bloccante.  In ambiente di <b>PRODUZIONE</b> il controllo sar√† bloccante.    Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_hash_post_with_http_info(numero_fir, dati_per_firma_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiunge la firma (required)
        :type numero_fir: str
        :param dati_per_firma_model: Informazioni necessarie per il calcolo del codice hash da firmare (required)
        :type dati_per_firma_model: DatiPerFirmaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_per_firma_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_hash_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_per_firma_model'] is not None:
            _body_params = _params['dati_per_firma_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/hash', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_invia_a_dispositivo_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], credentials_id : Annotated[StrictStr, Field(..., description="Identificativo delle credenziali")], **kwargs) -> None:  # noqa: E501
        """Invia il FIR ad un dispositivo  # noqa: E501

        Effettua l'invio delle informazioni di un formulario al dispositivo associato all'identificativo delle credenziali.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  Le credenziali indicate nel parametro <b>credentials_id</b> devono essere state create attraverso le API \"Firma remota RENTRI\",  e devono essere associate o all'unit√† locale che ha creato il FIR digitale, oppure ad una delle unit√† locali che abbiano gi√† acquisito la visibilit√† del FIR digitale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_invia_a_dispositivo_post(numero_fir, credentials_id, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param credentials_id: Identificativo delle credenziali (required)
        :type credentials_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_invia_a_dispositivo_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_invia_a_dispositivo_post_with_http_info(numero_fir, credentials_id, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_invia_a_dispositivo_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], credentials_id : Annotated[StrictStr, Field(..., description="Identificativo delle credenziali")], **kwargs) -> ApiResponse:  # noqa: E501
        """Invia il FIR ad un dispositivo  # noqa: E501

        Effettua l'invio delle informazioni di un formulario al dispositivo associato all'identificativo delle credenziali.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  Le credenziali indicate nel parametro <b>credentials_id</b> devono essere state create attraverso le API \"Firma remota RENTRI\",  e devono essere associate o all'unit√† locale che ha creato il FIR digitale, oppure ad una delle unit√† locali che abbiano gi√† acquisito la visibilit√† del FIR digitale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_invia_a_dispositivo_post_with_http_info(numero_fir, credentials_id, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param credentials_id: Identificativo delle credenziali (required)
        :type credentials_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'credentials_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_invia_a_dispositivo_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        if _params.get('credentials_id') is not None:  # noqa: E501
            _query_params.append(('credentials_id', _params['credentials_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/{numero_fir}/invia-a-dispositivo', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_note_annullamento_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], note_annullamento_model : Annotated[NoteAnnullamentoModel, Field(..., description="Dati di annullamento")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Imposta le note di annullamento del FIR  # noqa: E501

        Acquisisce la richiesta di aggiunta delle note di annullamento per il FIR specificato.  L'operazione pu√≤ essere richiesta solo da un utenza che abbia incarichi per (o coincida con) il soggetto che, tra produttore e trasportatore iniziale, ha vidimato il numero FIR.  Stati del formulario ammessi: <ul><li>Annullato (il formulario deve essere privo di note)</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_note_annullamento_post(numero_fir, note_annullamento_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param note_annullamento_model: Dati di annullamento (required)
        :type note_annullamento_model: NoteAnnullamentoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_note_annullamento_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_note_annullamento_post_with_http_info(numero_fir, note_annullamento_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_note_annullamento_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], note_annullamento_model : Annotated[NoteAnnullamentoModel, Field(..., description="Dati di annullamento")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Imposta le note di annullamento del FIR  # noqa: E501

        Acquisisce la richiesta di aggiunta delle note di annullamento per il FIR specificato.  L'operazione pu√≤ essere richiesta solo da un utenza che abbia incarichi per (o coincida con) il soggetto che, tra produttore e trasportatore iniziale, ha vidimato il numero FIR.  Stati del formulario ammessi: <ul><li>Annullato (il formulario deve essere privo di note)</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_note_annullamento_post_with_http_info(numero_fir, note_annullamento_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param note_annullamento_model: Dati di annullamento (required)
        :type note_annullamento_model: NoteAnnullamentoModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'note_annullamento_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_note_annullamento_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['note_annullamento_model'] is not None:
            _body_params = _params['note_annullamento_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/note-annullamento', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_pdf_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], **kwargs) -> DownloadableBaseResponse:  # noqa: E501
        """Stampa PDF del FIR  # noqa: E501

        Ottiene una stampa in PDF del FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_pdf_get(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DownloadableBaseResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_pdf_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_pdf_get_with_http_info(numero_fir, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_pdf_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stampa PDF del FIR  # noqa: E501

        Ottiene una stampa in PDF del FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_pdf_get_with_http_info(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DownloadableBaseResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_pdf_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "DownloadableBaseResponse",
            '204': None,
            '400': None,
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/pdf', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_put(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], nuovo_formulario_model : Annotated[NuovoFormularioModel, Field(..., description="Dati del formulario da sostituire a quelli presenti")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Modifica FIR  # noqa: E501

        Acquisisce la richiesta di modifica dei dati di un FIR esistente.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto produttore o il soggetto del primo trasportatore indicati nel formulario originale.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_put(numero_fir, nuovo_formulario_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param nuovo_formulario_model: Dati del formulario da sostituire a quelli presenti (required)
        :type nuovo_formulario_model: NuovoFormularioModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_put_with_http_info(numero_fir, nuovo_formulario_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_put_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], nuovo_formulario_model : Annotated[NuovoFormularioModel, Field(..., description="Dati del formulario da sostituire a quelli presenti")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Modifica FIR  # noqa: E501

        Acquisisce la richiesta di modifica dei dati di un FIR esistente.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto produttore o il soggetto del primo trasportatore indicati nel formulario originale.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_put_with_http_info(numero_fir, nuovo_formulario_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param nuovo_formulario_model: Dati del formulario da sostituire a quelli presenti (required)
        :type nuovo_formulario_model: NuovoFormularioModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'nuovo_formulario_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['nuovo_formulario_model'] is not None:
            _body_params = _params['nuovo_formulario_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_quantita_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], quantita_rifiuto_model : QuantitaRifiutoModel, x_reply_to : Optional[StrictStr] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Imposta quantit√†  # noqa: E501

        Acquisice la richiesta di aggiunta o modifica del dato della quantit√† sul formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il produttore o il primo trasportatore.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_quantita_post(numero_fir, quantita_rifiuto_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param quantita_rifiuto_model:  (required)
        :type quantita_rifiuto_model: QuantitaRifiutoModel
        :param x_reply_to: 
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_quantita_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_quantita_post_with_http_info(numero_fir, quantita_rifiuto_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_quantita_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], quantita_rifiuto_model : QuantitaRifiutoModel, x_reply_to : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Imposta quantit√†  # noqa: E501

        Acquisice la richiesta di aggiunta o modifica del dato della quantit√† sul formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il produttore o il primo trasportatore.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>FirmaProduttoreTrasportatoreIniziale</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_quantita_post_with_http_info(numero_fir, quantita_rifiuto_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param quantita_rifiuto_model:  (required)
        :type quantita_rifiuto_model: QuantitaRifiutoModel
        :param x_reply_to: 
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'quantita_rifiuto_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_quantita_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quantita_rifiuto_model'] is not None:
            _body_params = _params['quantita_rifiuto_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/quantita', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_reset_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Reset stato  # noqa: E501

        Acquisisce la richiesta di cancellazione degli ultimi dati inseriti nel formulario in attesa di firma, riportando lo stato del formulario a quello precedente.  La cancellazione degli ultimi dati inseriti (e non ancora firmati) √® consentita solo alle utenze con visibilit√† per (o che coincidono con)  gli stessi soggetti coinvolti nel formulario a cui √® consentito l'inserimento del tipo di informazione che si sta eliminando. Stati del formulario ammessi: <ul><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAccettazioneSuccessiva</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_reset_post(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_reset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_reset_post_with_http_info(numero_fir, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_reset_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Reset stato  # noqa: E501

        Acquisisce la richiesta di cancellazione degli ultimi dati inseriti nel formulario in attesa di firma, riportando lo stato del formulario a quello precedente.  La cancellazione degli ultimi dati inseriti (e non ancora firmati) √® consentita solo alle utenze con visibilit√† per (o che coincidono con)  gli stessi soggetti coinvolti nel formulario a cui √® consentito l'inserimento del tipo di informazione che si sta eliminando. Stati del formulario ammessi: <ul><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaDestinatarioSuccessivo</li><li>FirmaAccettazione</li><li>FirmaAccettazioneSuccessiva</li><li>FirmaAnnotazione</li><li>FirmaAnnullamento</li><li>FirmaTrasbordoParziale</li><li>FirmaTrasbordoTotale</li><li>FirmaSostaTecnica</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_reset_post_with_http_info(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_reset_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/reset', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_respingi_post(self, numero_fir : constr(strict=True), num_iscr_sito : Optional[constr(strict=True)] = None, **kwargs) -> None:  # noqa: E501
        """(Deprecated) ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/rilascio-visibilita/{numIscrSito} - Rilascio visibilit√† FIR  # noqa: E501

        Abbandona la visibilit√† in ricerca sull'unit√† locale specificata, ottenuta con l'operazione di \"acquisizione di visibilit√†\", relativamente al FIR digitale specificato creato da terzi.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_respingi_post(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito:
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_respingi_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_respingi_post_with_http_info(numero_fir, num_iscr_sito, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_respingi_post_with_http_info(self, numero_fir : constr(strict=True), num_iscr_sito : Optional[constr(strict=True)] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) ‚ö†Ô∏è[DEPRECATO] - utilizzare /{numeroFIR}/rilascio-visibilita/{numIscrSito} - Rilascio visibilit√† FIR  # noqa: E501

        Abbandona la visibilit√† in ricerca sull'unit√† locale specificata, ottenuta con l'operazione di \"acquisizione di visibilit√†\", relativamente al FIR digitale specificato creato da terzi.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_respingi_post_with_http_info(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito:
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        warnings.warn("POST /{numero_fir}/respingi is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'numero_fir',
            'num_iscr_sito'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_respingi_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        if _params.get('num_iscr_sito') is not None:  # noqa: E501
            _query_params.append(('num_iscr_sito', _params['num_iscr_sito']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/{numero_fir}/respingi', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_rilascio_visibilita_num_iscr_sito_post(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> None:  # noqa: E501
        """Rilascio visibilit√† FIR  # noqa: E501

        Abbandona la visibilit√† in ricerca sull'unit√† locale specificata, ottenuta con l'operazione di \"acquisizione\", relativamente al FIR digitale specificato creato da terzi.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_rilascio_visibilita_num_iscr_sito_post(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_rilascio_visibilita_num_iscr_sito_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_rilascio_visibilita_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_rilascio_visibilita_num_iscr_sito_post_with_http_info(self, numero_fir : constr(strict=True), num_iscr_sito : constr(strict=True), **kwargs) -> ApiResponse:  # noqa: E501
        """Rilascio visibilit√† FIR  # noqa: E501

        Abbandona la visibilit√† in ricerca sull'unit√† locale specificata, ottenuta con l'operazione di \"acquisizione\", relativamente al FIR digitale specificato creato da terzi.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_rilascio_visibilita_num_iscr_sito_post_with_http_info(numero_fir, num_iscr_sito, async_req=True)
        >>> result = thread.get()

        :param numero_fir: (required)
        :type numero_fir: str
        :param num_iscr_sito: (required)
        :type num_iscr_sito: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'num_iscr_sito'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_rilascio_visibilita_num_iscr_sito_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']

        if _params['num_iscr_sito'] is not None:
            _path_params['num_iscr_sito'] = _params['num_iscr_sito']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/{numero_fir}/rilascio-visibilita/{num_iscr_sito}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_rollback_firma_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Rollback dell'ultima firma  # noqa: E501

        Acquisisce la richiesta di rollback dell'ultima firma apposta (tranne la firma di annullamento) riportando lo stato del formulario a quello di attesa firma precedente alla sua apposizione.  L'operazione di apposizione delle firme digitali in un FIR attraverso gli endpoint di queste API √® reversibile solo a determinate condizioni: <ul><li>la firma √® l'ultima apposta al FIR digitale in ordine temporale</li><li>la firma √® stata apposta con le API RENTRI senza che il file sia stato ricaricato con un'operazione di upload dopo la sua apposizione</li><li>la firma √® stata apposta su dati riferiti ad un soggetto che coincide con l'identit√† di chi invoca l'endpoint (o per cui l'utente che invoca l'endpoint ha visibilit√†)</li><li>la firma √® stata apposta entro i 15 minuti precedenti al momento in cui si richiede l'operazione (calcolati dalla data firma presente nella struttura dati XAdES del file di firma)</li><li>non √® stata effettuata, dopo l'acquisizione della firma, alcuna operazione di download (via API, portale Operatori iscritti, App RENTRI) del file xFIR attraverso <i>GET /{numero_fir}/xfir</i>; da parte di alcun soggetto che abbia visibilit√† del FIR</li><li>non √® presente a sistema una copia cartacea con lo stesso numero FIR restituita dal trasportatore agli altri soggetti coinvolti nel FIR</li><li>non √® presente a sistema una copia digitale con lo stesso numero FIR restituita dal destinatario agli altri soggetti coinvolti nel FIR</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_rollback_firma_post(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_rollback_firma_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_rollback_firma_post_with_http_info(numero_fir, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_rollback_firma_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Rollback dell'ultima firma  # noqa: E501

        Acquisisce la richiesta di rollback dell'ultima firma apposta (tranne la firma di annullamento) riportando lo stato del formulario a quello di attesa firma precedente alla sua apposizione.  L'operazione di apposizione delle firme digitali in un FIR attraverso gli endpoint di queste API √® reversibile solo a determinate condizioni: <ul><li>la firma √® l'ultima apposta al FIR digitale in ordine temporale</li><li>la firma √® stata apposta con le API RENTRI senza che il file sia stato ricaricato con un'operazione di upload dopo la sua apposizione</li><li>la firma √® stata apposta su dati riferiti ad un soggetto che coincide con l'identit√† di chi invoca l'endpoint (o per cui l'utente che invoca l'endpoint ha visibilit√†)</li><li>la firma √® stata apposta entro i 15 minuti precedenti al momento in cui si richiede l'operazione (calcolati dalla data firma presente nella struttura dati XAdES del file di firma)</li><li>non √® stata effettuata, dopo l'acquisizione della firma, alcuna operazione di download (via API, portale Operatori iscritti, App RENTRI) del file xFIR attraverso <i>GET /{numero_fir}/xfir</i>; da parte di alcun soggetto che abbia visibilit√† del FIR</li><li>non √® presente a sistema una copia cartacea con lo stesso numero FIR restituita dal trasportatore agli altri soggetti coinvolti nel FIR</li><li>non √® presente a sistema una copia digitale con lo stesso numero FIR restituita dal destinatario agli altri soggetti coinvolti nel FIR</li></ul> Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_rollback_firma_post_with_http_info(numero_fir, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_rollback_firma_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/rollback-firma', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_sosta_tecnica_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati di sosta tecnica")], dati_sosta_tecnica_model : Annotated[DatiSostaTecnicaModel, Field(..., description="Dati con il dettaglio della sosta")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge sosta tecnica  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di sosta tecnica per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_sosta_tecnica_post(numero_fir, dati_sosta_tecnica_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati di sosta tecnica (required)
        :type numero_fir: str
        :param dati_sosta_tecnica_model: Dati con il dettaglio della sosta (required)
        :type dati_sosta_tecnica_model: DatiSostaTecnicaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_sosta_tecnica_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_sosta_tecnica_post_with_http_info(numero_fir, dati_sosta_tecnica_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_sosta_tecnica_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati di sosta tecnica")], dati_sosta_tecnica_model : Annotated[DatiSostaTecnicaModel, Field(..., description="Dati con il dettaglio della sosta")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge sosta tecnica  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di sosta tecnica per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_sosta_tecnica_post_with_http_info(numero_fir, dati_sosta_tecnica_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati di sosta tecnica (required)
        :type numero_fir: str
        :param dati_sosta_tecnica_model: Dati con il dettaglio della sosta (required)
        :type dati_sosta_tecnica_model: DatiSostaTecnicaModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_sosta_tecnica_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_sosta_tecnica_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_sosta_tecnica_model'] is not None:
            _body_params = _params['dati_sosta_tecnica_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/sosta-tecnica', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_stato_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero del FIR per il quale si richiede lo stato")], **kwargs) -> InfoFormulario:  # noqa: E501
        """Stato FIR  # noqa: E501

        Restituisce lo stato del formulario  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_stato_get(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero del FIR per il quale si richiede lo stato (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InfoFormulario
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_stato_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_stato_get_with_http_info(numero_fir, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_stato_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero del FIR per il quale si richiede lo stato")], **kwargs) -> ApiResponse:  # noqa: E501
        """Stato FIR  # noqa: E501

        Restituisce lo stato del formulario  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_stato_get_with_http_info(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero del FIR per il quale si richiede lo stato (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InfoFormulario, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_stato_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "InfoFormulario",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/stato', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_trasbordo_parziale_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati del trasbordo")], dati_trasbordo_parziale_model : Annotated[DatiTrasbordoParzialeModel, Field(..., description="Dati con il dettaglio del trasbordo parziale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge trasbordo parziale  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di un trasbordo parziale per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasbordo_parziale_post(numero_fir, dati_trasbordo_parziale_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati del trasbordo (required)
        :type numero_fir: str
        :param dati_trasbordo_parziale_model: Dati con il dettaglio del trasbordo parziale (required)
        :type dati_trasbordo_parziale_model: DatiTrasbordoParzialeModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_trasbordo_parziale_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_trasbordo_parziale_post_with_http_info(numero_fir, dati_trasbordo_parziale_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_trasbordo_parziale_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati del trasbordo")], dati_trasbordo_parziale_model : Annotated[DatiTrasbordoParzialeModel, Field(..., description="Dati con il dettaglio del trasbordo parziale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge trasbordo parziale  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di un trasbordo parziale per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasbordo_parziale_post_with_http_info(numero_fir, dati_trasbordo_parziale_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati del trasbordo (required)
        :type numero_fir: str
        :param dati_trasbordo_parziale_model: Dati con il dettaglio del trasbordo parziale (required)
        :type dati_trasbordo_parziale_model: DatiTrasbordoParzialeModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_trasbordo_parziale_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_trasbordo_parziale_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_trasbordo_parziale_model'] is not None:
            _body_params = _params['dati_trasbordo_parziale_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/trasbordo-parziale', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_trasbordo_totale_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati del trasbordo totale")], dati_trasbordo_totale_model : Annotated[DatiTrasbordoTotaleModel, Field(..., description="Dati con il dettaglio del trasbordo totale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge trasbordo totale  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di un trasbordo totale per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> Il tipo del trasporto deve essere <b>\"Terrestre\"</b>.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasbordo_totale_post(numero_fir, dati_trasbordo_totale_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati del trasbordo totale (required)
        :type numero_fir: str
        :param dati_trasbordo_totale_model: Dati con il dettaglio del trasbordo totale (required)
        :type dati_trasbordo_totale_model: DatiTrasbordoTotaleModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_trasbordo_totale_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_trasbordo_totale_post_with_http_info(numero_fir, dati_trasbordo_totale_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_trasbordo_totale_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario a cui si aggiungono i dati del trasbordo totale")], dati_trasbordo_totale_model : Annotated[DatiTrasbordoTotaleModel, Field(..., description="Dati con il dettaglio del trasbordo totale")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge trasbordo totale  # noqa: E501

        Acquisisce la richiesta per l'aggiunta dei dati di un trasbordo totale per il formulario indicato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto trasportatore che risulta avere  in carico il rifiuto.  Stati del formulario ammessi: <ul><li>InserimentoAccettazione</li><li>InserimentoTrasportoSuccessivo</li></ul> Il tipo del trasporto deve essere <b>\"Terrestre\"</b>.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasbordo_totale_post_with_http_info(numero_fir, dati_trasbordo_totale_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario a cui si aggiungono i dati del trasbordo totale (required)
        :type numero_fir: str
        :param dati_trasbordo_totale_model: Dati con il dettaglio del trasbordo totale (required)
        :type dati_trasbordo_totale_model: DatiTrasbordoTotaleModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'dati_trasbordo_totale_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_trasbordo_totale_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['dati_trasbordo_totale_model'] is not None:
            _body_params = _params['dati_trasbordo_totale_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/trasbordo-totale', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_trasporto_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], numero_fir_trasporto_post_request : Annotated[NumeroFirTrasportoPostRequest, Field(..., description="Dati di trasporto del rifiuto")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge dati trasporto  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati di trasporto del rifiuto da parte del trasportatore che ha in carico il FIR specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto produttore o il soggetto trasportatore iniziale, nel caso il formulario non sia ancora stato firmato, oppure il trasportatore che effettua la presa in carico del rifiuto dal trasportatore precedente.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>InserimentoTrasportoSuccessivo</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaTrasbordoTotale</li></ul> Il tipo di modello passato come contenuto del POST determina la modalit√† del trasporto.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasporto_post(numero_fir, numero_fir_trasporto_post_request, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param numero_fir_trasporto_post_request: Dati di trasporto del rifiuto (required)
        :type numero_fir_trasporto_post_request: NumeroFirTrasportoPostRequest
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_trasporto_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_trasporto_post_with_http_info(numero_fir, numero_fir_trasporto_post_request, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_trasporto_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], numero_fir_trasporto_post_request : Annotated[NumeroFirTrasportoPostRequest, Field(..., description="Dati di trasporto del rifiuto")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Aggiunge dati trasporto  # noqa: E501

        Acquisisce la richiesta di aggiunta dei dati di trasporto del rifiuto da parte del trasportatore che ha in carico il FIR specificato.  L'operazione pu√≤ essere eseguita da un'utenza che abbia visibilit√† su (o coincida con) il soggetto produttore o il soggetto trasportatore iniziale, nel caso il formulario non sia ancora stato firmato, oppure il trasportatore che effettua la presa in carico del rifiuto dal trasportatore precedente.  Stati del formulario ammessi: <ul><li>InserimentoQuantita</li><li>InserimentoQuantitaTrasportoIniziale</li><li>InserimentoTrasportoIniziale</li><li>InserimentoTrasportoSuccessivo</li><li>FirmaProduttoreTrasportatoreIniziale</li><li>FirmaTrasportatoreIniziale (per formulario da trasbordo parziale)</li><li>FirmaTrasportatoreSuccessivo</li><li>FirmaTrasbordoTotale</li></ul> Il tipo di modello passato come contenuto del POST determina la modalit√† del trasporto.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_trasporto_post_with_http_info(numero_fir, numero_fir_trasporto_post_request, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param numero_fir_trasporto_post_request: Dati di trasporto del rifiuto (required)
        :type numero_fir_trasporto_post_request: NumeroFirTrasportoPostRequest
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'numero_fir_trasporto_post_request',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_trasporto_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['numero_fir_trasporto_post_request'] is not None:
            _body_params = _params['numero_fir_trasporto_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/trasporto', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_xfir_get(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], **kwargs) -> DownloadableBaseResponse:  # noqa: E501
        """Download xFIR  # noqa: E501

        Restituisce il file in formato xFIR che rappresenta il formulario specificato con il numero FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_xfir_get(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DownloadableBaseResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_xfir_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_xfir_get_with_http_info(numero_fir, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_xfir_get_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario")], **kwargs) -> ApiResponse:  # noqa: E501
        """Download xFIR  # noqa: E501

        Restituisce il file in formato xFIR che rappresenta il formulario specificato con il numero FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_xfir_get_with_http_info(numero_fir, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario (required)
        :type numero_fir: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DownloadableBaseResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_xfir_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "DownloadableBaseResponse",
            '400': None,
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/xfir', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def numero_fir_xfir_post(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario, deve coincidere con quello deducibile dalle informazioni presenti nel file xFIR")], upload_xfir_model : Annotated[UploadXfirModel, Field(..., description="Oggetto contenente il contenuto del file xFIR da caricare")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Upload xFIR  # noqa: E501

        Carica un file xFIR esterno nell'area virtuale di interscambio per permetterne l'aggiunta di informazioni e relative firme attraverso le API formulari.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  Se non esiste alcun FIR digitale in compilazione con lo stesso numero, l'endpoint lo aggiunge all'area virtuale di interscambio permettendone l'interazione con queste API.  Se il file xFIR √® gi√† presente nell'area virtuale di interscambio, e le informazioni contenute nel file caricato sono compatibili con quelle del file xFIR gi√† presente, l'endpoint aggiorna il file xFIR con quello caricato.   La compatibilit√† delle nuove informazioni rispetto a quelle eventualmente gi√† presenti in area virtuale di interscambio √® determinata dalla presenza degli stessi dati firmati e degli stessi valori per le relative firme crittografiche.  Il file xFIR inviato deve essere valido secondo le regole definite nella <i>Guida tecnica alla compilazione del FIR digitale</i>  e verificabile dalla specifica funzione di validazione definita dall'endpoint <i>Validazione xFIR</i>. Relativamente alle date dichiarate nell'apposizione delle firme presenti nel file xFIR, l'esito della validazione deve essere <i>Ok</i> per tutti i controlli con codice <i>firmaDataDichiarata</i>.  In ambiente di <b>PRODUZIONE</b>, la validazione dei controlli con codice <i>firmaDataDichiarata</i> sulle date dichiarate di firma presenti nei file XAdES dell'xFIR  avr√† esito positivo solo con date successive alle ore 00:00 del giorno 13/02/2026.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  La dimensione massima accettata del file xFIR √® 3 MB.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_xfir_post(numero_fir, upload_xfir_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario, deve coincidere con quello deducibile dalle informazioni presenti nel file xFIR (required)
        :type numero_fir: str
        :param upload_xfir_model: Oggetto contenente il contenuto del file xFIR da caricare (required)
        :type upload_xfir_model: UploadXfirModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the numero_fir_xfir_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.numero_fir_xfir_post_with_http_info(numero_fir, upload_xfir_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def numero_fir_xfir_post_with_http_info(self, numero_fir : Annotated[constr(strict=True), Field(..., description="Numero FIR del formulario, deve coincidere con quello deducibile dalle informazioni presenti nel file xFIR")], upload_xfir_model : Annotated[UploadXfirModel, Field(..., description="Oggetto contenente il contenuto del file xFIR da caricare")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Upload xFIR  # noqa: E501

        Carica un file xFIR esterno nell'area virtuale di interscambio per permetterne l'aggiunta di informazioni e relative firme attraverso le API formulari.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) almeno uno dei soggetti coinvolti nel formulario.  Se non esiste alcun FIR digitale in compilazione con lo stesso numero, l'endpoint lo aggiunge all'area virtuale di interscambio permettendone l'interazione con queste API.  Se il file xFIR √® gi√† presente nell'area virtuale di interscambio, e le informazioni contenute nel file caricato sono compatibili con quelle del file xFIR gi√† presente, l'endpoint aggiorna il file xFIR con quello caricato.   La compatibilit√† delle nuove informazioni rispetto a quelle eventualmente gi√† presenti in area virtuale di interscambio √® determinata dalla presenza degli stessi dati firmati e degli stessi valori per le relative firme crittografiche.  Il file xFIR inviato deve essere valido secondo le regole definite nella <i>Guida tecnica alla compilazione del FIR digitale</i>  e verificabile dalla specifica funzione di validazione definita dall'endpoint <i>Validazione xFIR</i>. Relativamente alle date dichiarate nell'apposizione delle firme presenti nel file xFIR, l'esito della validazione deve essere <i>Ok</i> per tutti i controlli con codice <i>firmaDataDichiarata</i>.  In ambiente di <b>PRODUZIONE</b>, la validazione dei controlli con codice <i>firmaDataDichiarata</i> sulle date dichiarate di firma presenti nei file XAdES dell'xFIR  avr√† esito positivo solo con date successive alle ore 00:00 del giorno 13/02/2026.  In caso esista una copia del FIR digitale gi√† restituita con accettazione totale del rifiuto, l'operazione non √® consentita.  La dimensione massima accettata del file xFIR √® 3 MB.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.numero_fir_xfir_post_with_http_info(numero_fir, upload_xfir_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param numero_fir: Numero FIR del formulario, deve coincidere con quello deducibile dalle informazioni presenti nel file xFIR (required)
        :type numero_fir: str
        :param upload_xfir_model: Oggetto contenente il contenuto del file xFIR da caricare (required)
        :type upload_xfir_model: UploadXfirModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'numero_fir',
            'upload_xfir_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method numero_fir_xfir_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['numero_fir'] is not None:
            _path_params['numero_fir'] = _params['numero_fir']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['upload_xfir_model'] is not None:
            _body_params = _params['upload_xfir_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/{numero_fir}/xfir', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def root_get(self, num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".")] = None, identificativo_soggetto : Annotated[Optional[StrictStr], Field(description="Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".")] = None, solo_senza_visibilita_siti : Annotated[Optional[StrictBool], Field(description="Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.")] = None, numero_fir : Annotated[Optional[StrictStr], Field(description="Numero del FIR")] = None, codice_blocco : Annotated[Optional[StrictStr], Field(description="Codice blocco del FIR")] = None, data_creazione_da : Annotated[Optional[datetime], Field(description="Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_creazione_a : Annotated[Optional[datetime], Field(description="Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_da : Annotated[Optional[datetime], Field(description="Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_a : Annotated[Optional[datetime], Field(description="Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, codice_eer : Annotated[Optional[constr(strict=True, max_length=8)], Field(description="Codice EER")] = None, stati : Optional[conlist(StrictStr)] = None, paging_page : Annotated[Optional[conint(strict=True, le=2147483647, ge=1)], Field(description="Valore per l'header Paging-Page.")] = None, paging_page_size : Annotated[Optional[conint(strict=True, le=1000, ge=1)], Field(description="Valore per l'header Paging-PageSize.")] = None, **kwargs) -> List[FormularioItemResult]:  # noqa: E501
        """Elenco formulari  # noqa: E501

        Ottiene l'elenco dei formulari richiesti con visibilit√† per l'unit√† locale indicata e con i filtri specificati.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_get(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, paging_page, paging_page_size, async_req=True)
        >>> result = thread.get()

        :param num_iscr_sito: Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".
        :type num_iscr_sito: str
        :param identificativo_soggetto: Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".
        :type identificativo_soggetto: str
        :param solo_senza_visibilita_siti: Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.
        :type solo_senza_visibilita_siti: bool
        :param numero_fir: Numero del FIR
        :type numero_fir: str
        :param codice_blocco: Codice blocco del FIR
        :type codice_blocco: str
        :param data_creazione_da: Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_da: datetime
        :param data_creazione_a: Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_a: datetime
        :param data_emissione_da: Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_da: datetime
        :param data_emissione_a: Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_a: datetime
        :param codice_eer: Codice EER
        :type codice_eer: str
        :param stati:
        :type stati: List[str]
        :param paging_page: Valore per l'header Paging-Page.
        :type paging_page: int
        :param paging_page_size: Valore per l'header Paging-PageSize.
        :type paging_page_size: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[FormularioItemResult]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the root_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.root_get_with_http_info(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, paging_page, paging_page_size, **kwargs)  # noqa: E501

    @validate_arguments
    def root_get_with_http_info(self, num_iscr_sito : Annotated[Optional[StrictStr], Field(description="Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".")] = None, identificativo_soggetto : Annotated[Optional[StrictStr], Field(description="Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".")] = None, solo_senza_visibilita_siti : Annotated[Optional[StrictBool], Field(description="Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.")] = None, numero_fir : Annotated[Optional[StrictStr], Field(description="Numero del FIR")] = None, codice_blocco : Annotated[Optional[StrictStr], Field(description="Codice blocco del FIR")] = None, data_creazione_da : Annotated[Optional[datetime], Field(description="Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_creazione_a : Annotated[Optional[datetime], Field(description="Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_da : Annotated[Optional[datetime], Field(description="Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, data_emissione_a : Annotated[Optional[datetime], Field(description="Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)")] = None, codice_eer : Annotated[Optional[constr(strict=True, max_length=8)], Field(description="Codice EER")] = None, stati : Optional[conlist(StrictStr)] = None, paging_page : Annotated[Optional[conint(strict=True, le=2147483647, ge=1)], Field(description="Valore per l'header Paging-Page.")] = None, paging_page_size : Annotated[Optional[conint(strict=True, le=1000, ge=1)], Field(description="Valore per l'header Paging-PageSize.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Elenco formulari  # noqa: E501

        Ottiene l'elenco dei formulari richiesti con visibilit√† per l'unit√† locale indicata e con i filtri specificati.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_get_with_http_info(num_iscr_sito, identificativo_soggetto, solo_senza_visibilita_siti, numero_fir, codice_blocco, data_creazione_da, data_creazione_a, data_emissione_da, data_emissione_a, codice_eer, stati, paging_page, paging_page_size, async_req=True)
        >>> result = thread.get()

        :param num_iscr_sito: Numero iscrizione unit√† locale rilasciato all'iscrizione per il quale si richiedono i formulari. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"identificativo_soggetto\".
        :type num_iscr_sito: str
        :param identificativo_soggetto: Identificativo del soggetto. Quando viene specificato vengono restituiti tutti i FIR digitali nei quali il valore specificato  coincide con il codice fiscale di uno dei soggetti indicati, indipendentemente dallo specifico ruolo  e indipendentemente dall'aver acquisito la visibilit√† del FIR digitale in una specifica Unit√† Locale. Il dato deve essere valorizzato in assenza di un valore per la propriet√† \"num_iscr_sito\".
        :type identificativo_soggetto: str
        :param solo_senza_visibilita_siti: Se valorizzata a true, quando viene valorizzata la propriet√† \"identificativo_soggetto\" esclude dalla lista restituita  i FIR per cui esiste gi√† visibilit√† per almeno un'unit√† locale riconducibile al soggetto stesso.
        :type solo_senza_visibilita_siti: bool
        :param numero_fir: Numero del FIR
        :type numero_fir: str
        :param codice_blocco: Codice blocco del FIR
        :type codice_blocco: str
        :param data_creazione_da: Data di creazione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_da: datetime
        :param data_creazione_a: Data massima di creazione per la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_creazione_a: datetime
        :param data_emissione_da: Data di emissione a partire dalla quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_da: datetime
        :param data_emissione_a: Data massima di emissione entro la quale si richiedono i formulari (formato ISO 8601 UTC)
        :type data_emissione_a: datetime
        :param codice_eer: Codice EER
        :type codice_eer: str
        :param stati:
        :type stati: List[str]
        :param paging_page: Valore per l'header Paging-Page.
        :type paging_page: int
        :param paging_page_size: Valore per l'header Paging-PageSize.
        :type paging_page_size: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[FormularioItemResult], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'num_iscr_sito',
            'identificativo_soggetto',
            'solo_senza_visibilita_siti',
            'numero_fir',
            'codice_blocco',
            'data_creazione_da',
            'data_creazione_a',
            'data_emissione_da',
            'data_emissione_a',
            'codice_eer',
            'stati',
            'paging_page',
            'paging_page_size'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method root_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('num_iscr_sito') is not None:  # noqa: E501
            _query_params.append(('num_iscr_sito', _params['num_iscr_sito']))

        if _params.get('identificativo_soggetto') is not None:  # noqa: E501
            _query_params.append(('identificativo_soggetto', _params['identificativo_soggetto']))

        if _params.get('solo_senza_visibilita_siti') is not None:  # noqa: E501
            _query_params.append(('solo_senza_visibilita_siti', _params['solo_senza_visibilita_siti']))

        if _params.get('numero_fir') is not None:  # noqa: E501
            _query_params.append(('numero_fir', _params['numero_fir']))

        if _params.get('codice_blocco') is not None:  # noqa: E501
            _query_params.append(('codice_blocco', _params['codice_blocco']))

        if _params.get('data_creazione_da') is not None:  # noqa: E501
            if isinstance(_params['data_creazione_da'], datetime):
                _query_params.append(('data_creazione_da', _params['data_creazione_da'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_creazione_da', _params['data_creazione_da']))

        if _params.get('data_creazione_a') is not None:  # noqa: E501
            if isinstance(_params['data_creazione_a'], datetime):
                _query_params.append(('data_creazione_a', _params['data_creazione_a'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_creazione_a', _params['data_creazione_a']))

        if _params.get('data_emissione_da') is not None:  # noqa: E501
            if isinstance(_params['data_emissione_da'], datetime):
                _query_params.append(('data_emissione_da', _params['data_emissione_da'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_emissione_da', _params['data_emissione_da']))

        if _params.get('data_emissione_a') is not None:  # noqa: E501
            if isinstance(_params['data_emissione_a'], datetime):
                _query_params.append(('data_emissione_a', _params['data_emissione_a'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('data_emissione_a', _params['data_emissione_a']))

        if _params.get('codice_eer') is not None:  # noqa: E501
            _query_params.append(('codice_eer', _params['codice_eer']))

        if _params.get('stati') is not None:  # noqa: E501
            _query_params.append(('stati', _params['stati']))
            _collection_formats['stati'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['paging_page'] is not None:
            _header_params['Paging-Page'] = _params['paging_page']

        if _params['paging_page_size'] is not None:
            _header_params['Paging-PageSize'] = _params['paging_page_size']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "List[FormularioItemResult]",
            '400': None,
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def root_post(self, nuovo_formulario_model : Annotated[NuovoFormularioModel, Field(..., description="Dati del formulario da creare")], codice_blocco : Annotated[Optional[constr(strict=True)], Field(description="Codice blocco dal nuovo dal quale verr√† vidimato in automatico il nuovo numero FIR da associare al formulario")] = None, x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Crea FIR  # noqa: E501

        Acquisisce la richiesta di creazione di un nuovo FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto produttore o il soggetto del primo trasportatore indicati nei dati del formulario usati come modello.  Il numero del nuovo FIR pu√≤ essere specificato nell'apposita propriet√† del modello, altrimenti verr√† generato automaticamente dal sistema dal blocco indicato nel parametro <b>codice_blocco</b>.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_post(nuovo_formulario_model, codice_blocco, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param nuovo_formulario_model: Dati del formulario da creare (required)
        :type nuovo_formulario_model: NuovoFormularioModel
        :param codice_blocco: Codice blocco dal nuovo dal quale verr√† vidimato in automatico il nuovo numero FIR da associare al formulario
        :type codice_blocco: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the root_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.root_post_with_http_info(nuovo_formulario_model, codice_blocco, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def root_post_with_http_info(self, nuovo_formulario_model : Annotated[NuovoFormularioModel, Field(..., description="Dati del formulario da creare")], codice_blocco : Annotated[Optional[constr(strict=True)], Field(description="Codice blocco dal nuovo dal quale verr√† vidimato in automatico il nuovo numero FIR da associare al formulario")] = None, x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Crea FIR  # noqa: E501

        Acquisisce la richiesta di creazione di un nuovo FIR.  L'operazione pu√≤ essere eseguita da un'utenza che abbia incarichi per (o coincida con) il soggetto produttore o il soggetto del primo trasportatore indicati nei dati del formulario usati come modello.  Il numero del nuovo FIR pu√≤ essere specificato nell'apposita propriet√† del modello, altrimenti verr√† generato automaticamente dal sistema dal blocco indicato nel parametro <b>codice_blocco</b>.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_post_with_http_info(nuovo_formulario_model, codice_blocco, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param nuovo_formulario_model: Dati del formulario da creare (required)
        :type nuovo_formulario_model: NuovoFormularioModel
        :param codice_blocco: Codice blocco dal nuovo dal quale verr√† vidimato in automatico il nuovo numero FIR da associare al formulario
        :type codice_blocco: str
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'nuovo_formulario_model',
            'codice_blocco',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method root_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('codice_blocco') is not None:  # noqa: E501
            _query_params.append(('codice_blocco', _params['codice_blocco']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['nuovo_formulario_model'] is not None:
            _body_params = _params['nuovo_formulario_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '403': None,
            '404': None,
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def xfir_valida_post(self, valida_xfir_model : Annotated[ValidaXfirModel, Field(..., description="Oggetto contenente il contenuto del file xFIR")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> TransazioneModel:  # noqa: E501
        """üîÅ[ASYNC] Validazione xFIR  # noqa: E501

        Acquisisce la richiesta di controllo di validit√† dei dati contenuti nel file xFIR secondo le specifiche del formato definite nella <i>Guida tecnica alla struttura del FIR digitale</i>.  L'operazione pu√≤ essere eseguita da qualsiasi utenza o soggetto, non necessariamente coinvolta nel formulario.  La dimensione massima accettata del file xFIR √® 3 MB.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.xfir_valida_post(valida_xfir_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param valida_xfir_model: Oggetto contenente il contenuto del file xFIR (required)
        :type valida_xfir_model: ValidaXfirModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TransazioneModel
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the xfir_valida_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.xfir_valida_post_with_http_info(valida_xfir_model, x_reply_to, **kwargs)  # noqa: E501

    @validate_arguments
    def xfir_valida_post_with_http_info(self, valida_xfir_model : Annotated[ValidaXfirModel, Field(..., description="Oggetto contenente il contenuto del file xFIR")], x_reply_to : Annotated[Optional[StrictStr], Field(description="URL di callback alla quale verr√† inviata la notifica di fine elaborazione")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """üîÅ[ASYNC] Validazione xFIR  # noqa: E501

        Acquisisce la richiesta di controllo di validit√† dei dati contenuti nel file xFIR secondo le specifiche del formato definite nella <i>Guida tecnica alla struttura del FIR digitale</i>.  L'operazione pu√≤ essere eseguita da qualsiasi utenza o soggetto, non necessariamente coinvolta nel formulario.  La dimensione massima accettata del file xFIR √® 3 MB.  Con l'identificativo della transazione restituito √® possibile consultare lo stato di avanzamento dell'elaborazione e richiederne l'esito.<br/>Se viene specificato un URL nell'header <i>X-ReplyTo</i>, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.xfir_valida_post_with_http_info(valida_xfir_model, x_reply_to, async_req=True)
        >>> result = thread.get()

        :param valida_xfir_model: Oggetto contenente il contenuto del file xFIR (required)
        :type valida_xfir_model: ValidaXfirModel
        :param x_reply_to: URL di callback alla quale verr√† inviata la notifica di fine elaborazione
        :type x_reply_to: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TransazioneModel, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'valida_xfir_model',
            'x_reply_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method xfir_valida_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_reply_to'] is not None:
            _header_params['X-ReplyTo'] = _params['x_reply_to']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['valida_xfir_model'] is not None:
            _body_params = _params['valida_xfir_model']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/problem+json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "TransazioneModel",
            '400': "ProblemDetails",
            '423': None,
            '429': None,
            '500': "ProblemDetails",
        }

        return self.api_client.call_api(
            '/xfir/valida', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
